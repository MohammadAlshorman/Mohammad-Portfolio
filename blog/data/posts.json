[
  {
    "id": "law-firm-management-system",
    "title": "نظام إدارة مكاتب المحاماة الشامل باستخدام ASP.NET Core",
    "excerpt": "تطوير نظام شامل لإدارة مكاتب المحاماة يتضمن إدارة القضايا، المواعيد، العملاء والفواتير باستخدام ASP.NET Core وSQL Server.",
    "content": "<h2>المقدمة</h2><p>في عالم القانون المعقد، تحتاج مكاتب المحاماة إلى أنظمة إدارة متطورة تساعدهم على تنظيم أعمالهم وتحسين كفاءتهم. في هذا المقال، سنستعرض كيفية تطوير نظام شامل لإدارة مكاتب المحاماة باستخدام ASP.NET Core.</p><h2>متطلبات النظام</h2><ul><li><strong>إدارة القضايا:</strong> تتبع جميع القضايا مع تفاصيلها وحالتها</li><li><strong>إدارة العملاء:</strong> قاعدة بيانات شاملة للعملاء</li><li><strong>إدارة المواعيد:</strong> تنظيم المواعيد والجلسات</li><li><strong>النظام المالي:</strong> إدارة الفواتير والمدفوعات</li><li><strong>إدارة الوثائق:</strong> تخزين وتنظيم الملفات</li></ul><h2>الهيكل التقني</h2><h3>التقنيات المستخدمة</h3><ul><li><strong>Backend:</strong> ASP.NET Core 8.0</li><li><strong>Frontend:</strong> Angular 17</li><li><strong>قاعدة البيانات:</strong> SQL Server</li><li><strong>ORM:</strong> Entity Framework Core</li><li><strong>Authentication:</strong> JWT Tokens</li></ul><h3>معمارية النظام</h3><pre><code>LawFirmSystem/\n├── LawFirm.API/          # Web API Layer\n├── LawFirm.Core/         # Business Logic\n├── LawFirm.Data/         # Data Access Layer\n├── LawFirm.Models/       # Domain Models\n└── LawFirm.Client/       # Angular Frontend</code></pre><h2>إدارة القضايا</h2><p>يوفر النظام إدارة شاملة للقضايا تتضمن:</p><ul><li>تسجيل قضايا جديدة مع جميع التفاصيل</li><li>تتبع حالة القضايا (مفتوحة، مغلقة، مؤجلة)</li><li>ربط القضايا بالعملاء والمحامين</li><li>جدولة الجلسات والمواعيد</li><li>تخزين المرافعات والوثائق</li></ul><h3>نموذج البيانات للقضايا</h3><pre><code>public class Case\n{\n    public int Id { get; set; }\n    public string CaseNumber { get; set; }\n    public string Title { get; set; }\n    public string Description { get; set; }\n    public CaseStatus Status { get; set; }\n    public DateTime CreatedDate { get; set; }\n    public int ClientId { get; set; }\n    public Client Client { get; set; }\n    public int LawyerId { get; set; }\n    public Lawyer Lawyer { get; set; }\n    public List&lt;Hearing&gt; Hearings { get; set; }\n    public List&lt;Document&gt; Documents { get; set; }\n}</code></pre><h2>النظام المالي</h2><p>يتضمن النظام نظاماً مالياً متكاملاً لإدارة:</p><ul><li><strong>الفواتير:</strong> إنشاء وإرسال الفواتير للعملاء</li><li><strong>المدفوعات:</strong> تتبع المدفوعات الواردة</li><li><strong>التقارير المالية:</strong> تقارير شاملة عن الإيرادات</li><li><strong>إدارة الأتعاب:</strong> حساب أتعاب المحامين</li></ul><h2>الأمان والحماية</h2><p>يوفر النظام مستويات أمان متقدمة:</p><ul><li><strong>Authentication:</strong> نظام مصادقة آمن باستخدام JWT</li><li><strong>Authorization:</strong> صلاحيات متدرجة للمستخدمين</li><li><strong>Data Encryption:</strong> تشفير البيانات الحساسة</li><li><strong>Audit Trail:</strong> تسجيل جميع العمليات</li></ul><h2>التقارير والإحصائيات</h2><p>يوفر النظام تقارير شاملة تشمل:</p><ul><li>تقارير القضايا حسب الحالة والنوع</li><li>تقارير الأداء للمحامين</li><li>التقارير المالية الشهرية والسنوية</li><li>إحصائيات العملاء والقضايا الجديدة</li></ul><h2>الخلاصة</h2><p>نظام إدارة مكاتب المحاماة المطور باستخدام ASP.NET Core يوفر حلاً شاملاً ومتطوراً لإدارة جميع جوانب العمل القانوني. من خلال استخدام أحدث التقنيات والممارسات الأمنية، يضمن النظام كفاءة عالية في العمل وحماية تامة للبيانات الحساسة.</p><p>هذا النظام يمثل نموذجاً مثالياً لكيفية استخدام تقنيات Microsoft الحديثة في تطوير حلول الأعمال المتخصصة.</p>",
    "coverImage": "assets/img/posts/mohammad-alshorman-full-stack-developer.webp",
    "date": "2024-01-15",
    "dateModified": "2024-01-20",
    "author": "محمد شحادة الشرمان",
    "lang": "ar",
    "dir": "rtl",
    "tags": ["ASP.NET Core", "القانون", "إدارة الأعمال", "SQL Server", "Angular"],
    "readTime": 8,
    "category": "تطوير الأنظمة",
    "slug": "law-firm-management-system"
  },
  {
    "id": "rest-api-best-practices",
    "title": "أفضل الممارسات في تطوير REST APIs باستخدام ASP.NET Core",
    "excerpt": "دليل شامل لتطوير واجهات برمجة التطبيقات REST باستخدام ASP.NET Core مع التركيز على الأمان، الأداء، والتوثيق.",
    "content": "<h2>مقدمة حول REST APIs</h2><p>واجهات برمجة التطبيقات REST تُعتبر العمود الفقري للتطبيقات الحديثة. في هذا المقال، سنستعرض أفضل الممارسات لتطوير APIs قوية وآمنة باستخدام ASP.NET Core.</p><h2>هيكلة المشروع الصحيحة</h2><p>البداية الصحيحة تتطلب هيكلة مشروع منظمة:</p><pre><code>MyAPI/\n├── Controllers/           # API Controllers\n├── Models/               # Data Models\n├── Services/             # Business Logic\n├── Data/                 # Data Access\n├── Middleware/           # Custom Middleware\n├── DTOs/                 # Data Transfer Objects\n└── Configuration/        # App Configuration</code></pre><h2>تصميم نقاط النهاية (Endpoints)</h2><h3>استخدام HTTP Methods بشكل صحيح</h3><ul><li><strong>GET:</strong> للاستعلام عن البيانات</li><li><strong>POST:</strong> لإنشاء بيانات جديدة</li><li><strong>PUT:</strong> لتحديث البيانات كاملة</li><li><strong>PATCH:</strong> لتحديث جزئي</li><li><strong>DELETE:</strong> لحذف البيانات</li></ul><h3>مثال على تصميم صحيح</h3><pre><code>[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    [HttpGet]\n    public async Task&lt;ActionResult&lt;IEnumerable&lt;ProductDto&gt;&gt; GetProducts(\n        [FromQuery] ProductFilter filter)\n    {\n        var products = await _productService.GetProductsAsync(filter);\n        return Ok(products);\n    }\n\n    [HttpGet(\"{id}\")]\n    public async Task&lt;ActionResult&lt;ProductDto&gt;&gt; GetProduct(int id)\n    {\n        var product = await _productService.GetProductByIdAsync(id);\n        \n        if (product == null)\n            return NotFound();\n            \n        return Ok(product);\n    }\n\n    [HttpPost]\n    public async Task&lt;ActionResult&lt;ProductDto&gt;&gt; CreateProduct(\n        CreateProductDto createProductDto)\n    {\n        var product = await _productService.CreateProductAsync(createProductDto);\n        \n        return CreatedAtAction(\n            nameof(GetProduct), \n            new { id = product.Id }, \n            product);\n    }\n}</code></pre><h2>التعامل مع الأخطاء بطريقة احترافية</h2><h3>إنشاء Middleware للأخطاء</h3><pre><code>public class ErrorHandlingMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogger&lt;ErrorHandlingMiddleware&gt; _logger;\n\n    public ErrorHandlingMiddleware(\n        RequestDelegate next, \n        ILogger&lt;ErrorHandlingMiddleware&gt; logger)\n    {\n        _next = next;\n        _logger = logger;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        try\n        {\n            await _next(context);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"An unexpected error occurred\");\n            await HandleExceptionAsync(context, ex);\n        }\n    }\n\n    private static async Task HandleExceptionAsync(\n        HttpContext context, \n        Exception exception)\n    {\n        var response = new ErrorResponse\n        {\n            Message = \"An error occurred while processing your request\",\n            Details = exception.Message\n        };\n\n        context.Response.ContentType = \"application/json\";\n        context.Response.StatusCode = GetStatusCode(exception);\n\n        await context.Response.WriteAsync(\n            JsonSerializer.Serialize(response));\n    }\n}</code></pre><h2>أمان واجهات برمجة التطبيقات</h2><h3>المصادقة والترخيص</h3><ul><li><strong>JWT Authentication:</strong> استخدام رموز JWT للمصادقة</li><li><strong>Role-based Authorization:</strong> ترخيص قائم على الأدوار</li><li><strong>API Keys:</strong> استخدام مفاتيح API للتطبيقات الخارجية</li></ul><h3>مثال على JWT Configuration</h3><pre><code>public void ConfigureServices(IServiceCollection services)\n{\n    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n        .AddJwtBearer(options =>\n        {\n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ValidateIssuerSigningKey = true,\n                ValidIssuer = Configuration[\"Jwt:Issuer\"],\n                ValidAudience = Configuration[\"Jwt:Audience\"],\n                IssuerSigningKey = new SymmetricSecurityKey(\n                    Encoding.UTF8.GetBytes(Configuration[\"Jwt:Key\"]))\n            };\n        });\n}</code></pre><h2>تحسين الأداء</h2><h3>Caching استراتيجيات التخزين المؤقت</h3><ul><li><strong>In-Memory Caching:</strong> للبيانات المتكررة</li><li><strong>Distributed Caching:</strong> للتطبيقات متعددة الخوادم</li><li><strong>Response Caching:</strong> لتخزين الاستجابات</li></ul><h3>Pagination للبيانات الكبيرة</h3><pre><code>public class PagedResult&lt;T&gt;\n{\n    public List&lt;T&gt; Data { get; set; }\n    public int TotalCount { get; set; }\n    public int PageNumber { get; set; }\n    public int PageSize { get; set; }\n    public int TotalPages =&gt; (int)Math.Ceiling((double)TotalCount / PageSize);\n}\n\n[HttpGet]\npublic async Task&lt;ActionResult&lt;PagedResult&lt;ProductDto&gt;&gt;&gt; GetProducts(\n    int page = 1, \n    int pageSize = 10)\n{\n    var result = await _productService.GetPagedProductsAsync(page, pageSize);\n    return Ok(result);\n}</code></pre><h2>التوثيق باستخدام Swagger</h2><pre><code>public void ConfigureServices(IServiceCollection services)\n{\n    services.AddSwaggerGen(c =>\n    {\n        c.SwaggerDoc(\"v1\", new OpenApiInfo\n        {\n            Title = \"My API\",\n            Version = \"v1\",\n            Description = \"A comprehensive API documentation\"\n        });\n        \n        // Include XML comments\n        var xmlFile = $\"{Assembly.GetExecutingAssembly().GetName().Name}.xml\";\n        var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);\n        c.IncludeXmlComments(xmlPath);\n    });\n}</code></pre><h2>الاختبارات الشاملة</h2><h3>Unit Tests للوحدات</h3><pre><code>[Test]\npublic async Task GetProduct_WithValidId_ReturnsProduct()\n{\n    // Arrange\n    var productId = 1;\n    var expectedProduct = new Product { Id = productId, Name = \"Test Product\" };\n    _mockRepository.Setup(r =&gt; r.GetByIdAsync(productId))\n                  .ReturnsAsync(expectedProduct);\n\n    // Act\n    var result = await _productService.GetProductByIdAsync(productId);\n\n    // Assert\n    Assert.IsNotNull(result);\n    Assert.AreEqual(expectedProduct.Id, result.Id);\n}</code></pre><h2>مراقبة الأداء والتشخيص</h2><ul><li><strong>Application Insights:</strong> لمراقبة الأداء</li><li><strong>Health Checks:</strong> للتحقق من صحة النظام</li><li><strong>Logging:</strong> تسجيل شامل للأحداث</li></ul><h2>الخلاصة</h2><p>تطوير REST APIs احترافية يتطلب اتباع أفضل الممارسات في التصميم، الأمان، والأداء. باستخدام ASP.NET Core والإرشادات المذكورة، يمكنك إنشاء واجهات برمجة تطبيقات قوية وقابلة للصيانة.</p><p>التركيز على الجودة من البداية يوفر الكثير من الوقت والجهد في المراحل اللاحقة من التطوير.</p>",
    "coverImage": "assets/img/posts/aspnet-core-best-practices.webp",
    "date": "2024-02-10",
    "dateModified": "2024-02-15",
    "author": "محمد شحادة الشرمان",
    "lang": "ar",
    "dir": "rtl",
    "tags": ["ASP.NET Core", "REST API", "الأمان", "الأداء", "التوثيق"],
    "readTime": 12,
    "category": "تطوير الويب",
    "slug": "rest-api-best-practices"
  },
  {
    "id": "clean-architecture-dotnet",
    "title": "Implementing Clean Architecture in .NET Applications",
    "excerpt": "A comprehensive guide to implementing Clean Architecture patterns in .NET applications for maintainable, testable, and scalable software solutions.",
    "content": "<h2>Introduction to Clean Architecture</h2><p>Clean Architecture, popularized by Robert C. Martin (Uncle Bob), is a software design philosophy that emphasizes separation of concerns and dependency inversion. In this article, we'll explore how to implement Clean Architecture in .NET applications effectively.</p><h2>Core Principles of Clean Architecture</h2><h3>The Four Layers</h3><ul><li><strong>Enterprise Business Rules (Entities):</strong> Core business logic and rules</li><li><strong>Application Business Rules (Use Cases):</strong> Application-specific business rules</li><li><strong>Interface Adapters:</strong> Controllers, presenters, and gateways</li><li><strong>Frameworks and Drivers:</strong> Database, web framework, external services</li></ul><h3>The Dependency Rule</h3><p>The most important rule: <em>Dependencies can only point inward</em>. Nothing in an inner circle can know anything about something in an outer circle.</p><h2>Project Structure</h2><p>Let's organize our .NET solution following Clean Architecture principles:</p><pre><code>CleanArchitectureApp/\n├── src/\n│   ├── Domain/                    # Enterprise Business Rules\n│   │   ├── Entities/\n│   │   ├── ValueObjects/\n│   │   ├── Interfaces/\n│   │   └── Events/\n│   ├── Application/               # Application Business Rules\n│   │   ├── UseCases/\n│   │   ├── DTOs/\n│   │   ├── Interfaces/\n│   │   ├── Behaviors/\n│   │   └── Exceptions/\n│   ├── Infrastructure/            # Frameworks & Drivers\n│   │   ├── Data/\n│   │   ├── Services/\n│   │   ├── Repositories/\n│   │   └── Configuration/\n│   └── WebAPI/                    # Interface Adapters\n│       ├── Controllers/\n│       ├── Middleware/\n│       ├── Filters/\n│       └── Configuration/\n└── tests/\n    ├── UnitTests/\n    ├── IntegrationTests/\n    └── EndToEndTests/</code></pre><h2>Domain Layer Implementation</h2><h3>Entity Base Class</h3><pre><code>public abstract class Entity\n{\n    public int Id { get; protected set; }\n    public DateTime CreatedAt { get; protected set; }\n    public DateTime? UpdatedAt { get; protected set; }\n    \n    private readonly List&lt;IDomainEvent&gt; _domainEvents = new();\n    public IReadOnlyList&lt;IDomainEvent&gt; DomainEvents =&gt; _domainEvents.AsReadOnly();\n    \n    protected void AddDomainEvent(IDomainEvent domainEvent)\n    {\n        _domainEvents.Add(domainEvent);\n    }\n    \n    public void ClearDomainEvents()\n    {\n        _domainEvents.Clear();\n    }\n    \n    protected Entity()\n    {\n        CreatedAt = DateTime.UtcNow;\n    }\n}</code></pre><h3>Domain Entity Example</h3><pre><code>public class Product : Entity\n{\n    public string Name { get; private set; }\n    public string Description { get; private set; }\n    public decimal Price { get; private set; }\n    public int StockQuantity { get; private set; }\n    public bool IsActive { get; private set; }\n    \n    private Product() { } // For EF Core\n    \n    public Product(string name, string description, decimal price, int stockQuantity)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n            throw new ArgumentException(\"Product name cannot be empty\", nameof(name));\n        \n        if (price <= 0)\n            throw new ArgumentException(\"Product price must be positive\", nameof(price));\n            \n        Name = name;\n        Description = description;\n        Price = price;\n        StockQuantity = stockQuantity;\n        IsActive = true;\n        \n        AddDomainEvent(new ProductCreatedEvent(this));\n    }\n    \n    public void UpdatePrice(decimal newPrice)\n    {\n        if (newPrice <= 0)\n            throw new ArgumentException(\"Product price must be positive\", nameof(newPrice));\n            \n        var oldPrice = Price;\n        Price = newPrice;\n        UpdatedAt = DateTime.UtcNow;\n        \n        AddDomainEvent(new ProductPriceUpdatedEvent(this, oldPrice, newPrice));\n    }\n    \n    public void UpdateStock(int quantity)\n    {\n        if (quantity < 0)\n            throw new ArgumentException(\"Stock quantity cannot be negative\", nameof(quantity));\n            \n        StockQuantity = quantity;\n        UpdatedAt = DateTime.UtcNow;\n        \n        if (quantity == 0)\n            AddDomainEvent(new ProductOutOfStockEvent(this));\n    }\n}</code></pre><h2>Application Layer Implementation</h2><h3>Use Case Pattern</h3><pre><code>public interface ICreateProductUseCase\n{\n    Task&lt;ProductDto&gt; ExecuteAsync(CreateProductRequest request, CancellationToken cancellationToken);\n}\n\npublic class CreateProductUseCase : ICreateProductUseCase\n{\n    private readonly IProductRepository _productRepository;\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IMapper _mapper;\n    \n    public CreateProductUseCase(\n        IProductRepository productRepository,\n        IUnitOfWork unitOfWork,\n        IMapper mapper)\n    {\n        _productRepository = productRepository;\n        _unitOfWork = unitOfWork;\n        _mapper = mapper;\n    }\n    \n    public async Task&lt;ProductDto&gt; ExecuteAsync(\n        CreateProductRequest request, \n        CancellationToken cancellationToken)\n    {\n        // Validate business rules\n        var existingProduct = await _productRepository\n            .GetByNameAsync(request.Name, cancellationToken);\n            \n        if (existingProduct != null)\n            throw new ProductAlreadyExistsException(request.Name);\n        \n        // Create domain entity\n        var product = new Product(\n            request.Name,\n            request.Description,\n            request.Price,\n            request.StockQuantity);\n        \n        // Persist\n        await _productRepository.AddAsync(product, cancellationToken);\n        await _unitOfWork.SaveChangesAsync(cancellationToken);\n        \n        // Return DTO\n        return _mapper.Map&lt;ProductDto&gt;(product);\n    }\n}</code></pre><h3>CQRS with MediatR</h3><pre><code>public record CreateProductCommand(\n    string Name,\n    string Description,\n    decimal Price,\n    int StockQuantity) : IRequest&lt;ProductDto&gt;;\n\npublic class CreateProductCommandHandler : IRequestHandler&lt;CreateProductCommand, ProductDto&gt;\n{\n    private readonly ICreateProductUseCase _createProductUseCase;\n    \n    public CreateProductCommandHandler(ICreateProductUseCase createProductUseCase)\n    {\n        _createProductUseCase = createProductUseCase;\n    }\n    \n    public async Task&lt;ProductDto&gt; Handle(\n        CreateProductCommand request, \n        CancellationToken cancellationToken)\n    {\n        var createRequest = new CreateProductRequest\n        {\n            Name = request.Name,\n            Description = request.Description,\n            Price = request.Price,\n            StockQuantity = request.StockQuantity\n        };\n        \n        return await _createProductUseCase.ExecuteAsync(createRequest, cancellationToken);\n    }\n}</code></pre><h2>Infrastructure Layer Implementation</h2><h3>Repository Pattern</h3><pre><code>public class ProductRepository : IProductRepository\n{\n    private readonly ApplicationDbContext _context;\n    \n    public ProductRepository(ApplicationDbContext context)\n    {\n        _context = context;\n    }\n    \n    public async Task&lt;Product?&gt; GetByIdAsync(int id, CancellationToken cancellationToken)\n    {\n        return await _context.Products\n            .FirstOrDefaultAsync(p =&gt; p.Id == id, cancellationToken);\n    }\n    \n    public async Task&lt;Product?&gt; GetByNameAsync(string name, CancellationToken cancellationToken)\n    {\n        return await _context.Products\n            .FirstOrDefaultAsync(p =&gt; p.Name == name, cancellationToken);\n    }\n    \n    public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync(CancellationToken cancellationToken)\n    {\n        return await _context.Products\n            .Where(p =&gt; p.IsActive)\n            .ToListAsync(cancellationToken);\n    }\n    \n    public async Task AddAsync(Product product, CancellationToken cancellationToken)\n    {\n        await _context.Products.AddAsync(product, cancellationToken);\n    }\n    \n    public void Update(Product product)\n    {\n        _context.Products.Update(product);\n    }\n    \n    public void Delete(Product product)\n    {\n        _context.Products.Remove(product);\n    }\n}</code></pre><h2>Web API Layer Implementation</h2><h3>Controller with Clean Architecture</h3><pre><code>[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    private readonly IMediator _mediator;\n    \n    public ProductsController(IMediator mediator)\n    {\n        _mediator = mediator;\n    }\n    \n    [HttpPost]\n    public async Task&lt;ActionResult&lt;ProductDto&gt;&gt; CreateProduct(\n        [FromBody] CreateProductCommand command,\n        CancellationToken cancellationToken)\n    {\n        try\n        {\n            var result = await _mediator.Send(command, cancellationToken);\n            return CreatedAtAction(nameof(GetProduct), new { id = result.Id }, result);\n        }\n        catch (ProductAlreadyExistsException ex)\n        {\n            return Conflict(new { message = ex.Message });\n        }\n        catch (ArgumentException ex)\n        {\n            return BadRequest(new { message = ex.Message });\n        }\n    }\n    \n    [HttpGet(\"{id}\")]\n    public async Task&lt;ActionResult&lt;ProductDto&gt;&gt; GetProduct(\n        int id,\n        CancellationToken cancellationToken)\n    {\n        var query = new GetProductByIdQuery(id);\n        var result = await _mediator.Send(query, cancellationToken);\n        \n        if (result == null)\n            return NotFound();\n            \n        return Ok(result);\n    }\n}</code></pre><h2>Dependency Injection Configuration</h2><pre><code>public static class DependencyInjection\n{\n    public static IServiceCollection AddApplication(this IServiceCollection services)\n    {\n        services.AddMediatR(cfg =&gt; cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));\n        services.AddAutoMapper(Assembly.GetExecutingAssembly());\n        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());\n        \n        // Register use cases\n        services.AddScoped&lt;ICreateProductUseCase, CreateProductUseCase&gt;();\n        services.AddScoped&lt;IGetProductUseCase, GetProductUseCase&gt;();\n        \n        return services;\n    }\n    \n    public static IServiceCollection AddInfrastructure(\n        this IServiceCollection services, \n        IConfiguration configuration)\n    {\n        services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;\n            options.UseSqlServer(configuration.GetConnectionString(\"DefaultConnection\")));\n            \n        services.AddScoped&lt;IProductRepository, ProductRepository&gt;();\n        services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();\n        \n        return services;\n    }\n}</code></pre><h2>Testing Clean Architecture</h2><h3>Unit Testing Use Cases</h3><pre><code>[Test]\npublic async Task CreateProduct_WithValidData_ShouldReturnProductDto()\n{\n    // Arrange\n    var mockRepository = new Mock&lt;IProductRepository&gt;();\n    var mockUnitOfWork = new Mock&lt;IUnitOfWork&gt;();\n    var mockMapper = new Mock&lt;IMapper&gt;();\n    \n    var useCase = new CreateProductUseCase(\n        mockRepository.Object,\n        mockUnitOfWork.Object,\n        mockMapper.Object);\n    \n    var request = new CreateProductRequest\n    {\n        Name = \"Test Product\",\n        Description = \"Test Description\",\n        Price = 100m,\n        StockQuantity = 50\n    };\n    \n    var expectedDto = new ProductDto { Id = 1, Name = \"Test Product\" };\n    \n    mockRepository.Setup(r =&gt; r.GetByNameAsync(request.Name, It.IsAny&lt;CancellationToken&gt;()))\n                  .ReturnsAsync((Product?)null);\n    \n    mockMapper.Setup(m =&gt; m.Map&lt;ProductDto&gt;(It.IsAny&lt;Product&gt;()))\n              .Returns(expectedDto);\n    \n    // Act\n    var result = await useCase.ExecuteAsync(request, CancellationToken.None);\n    \n    // Assert\n    Assert.NotNull(result);\n    Assert.Equal(expectedDto.Name, result.Name);\n    \n    mockRepository.Verify(r =&gt; r.AddAsync(It.IsAny&lt;Product&gt;(), It.IsAny&lt;CancellationToken&gt;()), Times.Once);\n    mockUnitOfWork.Verify(u =&gt; u.SaveChangesAsync(It.IsAny&lt;CancellationToken&gt;()), Times.Once);\n}</code></pre><h2>Benefits of Clean Architecture</h2><ul><li><strong>Testability:</strong> Easy to unit test business logic</li><li><strong>Maintainability:</strong> Clear separation of concerns</li><li><strong>Flexibility:</strong> Easy to change frameworks and databases</li><li><strong>Independence:</strong> Core business logic is framework-agnostic</li><li><strong>Scalability:</strong> Well-organized code supports team growth</li></ul><h2>Common Pitfalls to Avoid</h2><ul><li><strong>Over-engineering:</strong> Don't apply Clean Architecture to simple applications</li><li><strong>Leaky abstractions:</strong> Ensure proper dependency direction</li><li><strong>Anemic domain models:</strong> Put business logic in domain entities</li><li><strong>Too many layers:</strong> Don't create unnecessary abstraction layers</li></ul><h2>Conclusion</h2><p>Clean Architecture provides a robust foundation for building maintainable and scalable .NET applications. By following the dependency rule and organizing code into distinct layers, you create systems that are easier to test, maintain, and evolve over time.</p><p>Remember that Clean Architecture is a guideline, not a rigid framework. Adapt it to your specific needs and context, always keeping the core principles in mind.</p>",
    "coverImage": "assets/img/posts/clean-architecture-dotnet.webp",
    "date": "2024-03-05",
    "dateModified": "2024-03-10",
    "author": "Mohammad Alshorman",
    "lang": "en",
    "dir": "ltr",
    "tags": ["Clean Architecture", ".NET", "Design Patterns", "Software Architecture", "SOLID Principles"],
    "readTime": 15,
    "category": "Software Architecture",
    "slug": "clean-architecture-dotnet"
  },
  {
    "id": "angular-performance-optimization",
    "title": "Angular Performance Optimization: Advanced Techniques and Best Practices",
    "excerpt": "Comprehensive guide to optimizing Angular applications for better performance, including lazy loading, change detection strategies, and bundle optimization.",
    "content": "<h2>Introduction to Angular Performance</h2><p>Performance is crucial for modern web applications. In this comprehensive guide, we'll explore advanced techniques to optimize Angular applications, covering everything from change detection strategies to advanced bundling techniques.</p><h2>Change Detection Optimization</h2><h3>OnPush Change Detection Strategy</h3><p>The default change detection strategy checks every component on every change detection cycle. Using OnPush can significantly improve performance:</p><pre><code>@Component({\n  selector: 'app-product',\n  template: `\n    &lt;div class=\"product-card\"&gt;\n      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;\n      &lt;p&gt;{{ product.price | currency }}&lt;/p&gt;\n      &lt;button (click)=\"addToCart()\"&gt;Add to Cart&lt;/button&gt;\n    &lt;/div&gt;\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ProductComponent {\n  @Input() product!: Product;\n  @Output() productAdded = new EventEmitter&lt;Product&gt;();\n  \n  constructor(private cdr: ChangeDetectorRef) {}\n  \n  addToCart() {\n    // Manually trigger change detection when needed\n    this.productAdded.emit(this.product);\n    this.cdr.markForCheck();\n  }\n}</code></pre><h3>Immutable Data Patterns</h3><p>When using OnPush, ensure you're working with immutable data:</p><pre><code>// ❌ Bad: Mutating existing object\nupdateProduct(productId: number, updates: Partial&lt;Product&gt;) {\n  const product = this.products.find(p =&gt; p.id === productId);\n  if (product) {\n    Object.assign(product, updates); // This won't trigger OnPush\n  }\n}\n\n// ✅ Good: Creating new object\nupdateProduct(productId: number, updates: Partial&lt;Product&gt;) {\n  this.products = this.products.map(product =&gt; \n    product.id === productId \n      ? { ...product, ...updates }\n      : product\n  );\n}</code></pre><h2>Lazy Loading and Code Splitting</h2><h3>Feature Module Lazy Loading</h3><pre><code>// app-routing.module.ts\nconst routes: Routes = [\n  {\n    path: 'products',\n    loadChildren: () =&gt; import('./features/products/products.module')\n      .then(m =&gt; m.ProductsModule)\n  },\n  {\n    path: 'orders',\n    loadChildren: () =&gt; import('./features/orders/orders.module')\n      .then(m =&gt; m.OrdersModule)\n  },\n  {\n    path: 'admin',\n    loadChildren: () =&gt; import('./features/admin/admin.module')\n      .then(m =&gt; m.AdminModule),\n    canLoad: [AdminGuard] // Only load if user has admin rights\n  }\n];</code></pre><h3>Standalone Components Lazy Loading (Angular 14+)</h3><pre><code>// Modern approach with standalone components\nconst routes: Routes = [\n  {\n    path: 'dashboard',\n    loadComponent: () =&gt; import('./dashboard/dashboard.component')\n      .then(c =&gt; c.DashboardComponent)\n  },\n  {\n    path: 'profile',\n    loadComponent: () =&gt; import('./profile/profile.component')\n      .then(c =&gt; c.ProfileComponent)\n  }\n];</code></pre><h2>Virtual Scrolling for Large Lists</h2><pre><code>// Template\n&lt;cdk-virtual-scroll-viewport itemSize=\"50\" class=\"viewport\"&gt;\n  &lt;div *cdkVirtualFor=\"let item of items; trackBy: trackByFn\" class=\"item\"&gt;\n    {{ item.name }}\n  &lt;/div&gt;\n&lt;/cdk-virtual-scroll-viewport&gt;\n\n// Component\n@Component({\n  selector: 'app-virtual-list',\n  template: `...`,\n  styles: [\n    '.viewport { height: 400px; }',\n    '.item { height: 50px; display: flex; align-items: center; }'\n  ]\n})\nexport class VirtualListComponent {\n  items = Array.from({ length: 100000 }, (_, i) =&gt; ({ \n    id: i, \n    name: `Item ${i}` \n  }));\n  \n  trackByFn(index: number, item: any) {\n    return item.id; // Use unique identifier\n  }\n}</code></pre><h2>Service Worker and Caching Strategies</h2><h3>Adding Service Worker</h3><pre><code># Add service worker to existing project\nng add @angular/pwa</code></pre><h3>Custom Caching Configuration</h3><pre><code>// ngsw-config.json\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/manifest.webmanifest\",\n          \"/*.css\",\n          \"/*.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/*.(eot|svg|cur|jpg|png|webp|gif|otf|ttf|woff|woff2|ani)\"\n        ]\n      }\n    }\n  ],\n  \"dataGroups\": [\n    {\n      \"name\": \"api-cache\",\n      \"urls\": [\"/api/**\"],\n      \"cacheConfig\": {\n        \"strategy\": \"freshness\",\n        \"maxSize\": 100,\n        \"maxAge\": \"1h\",\n        \"timeout\": \"5s\"\n      }\n    }\n  ]\n}</code></pre><h2>Bundle Optimization</h2><h3>Webpack Bundle Analyzer</h3><pre><code># Install webpack-bundle-analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n# Build and analyze\nng build --stats-json\nnpx webpack-bundle-analyzer dist/my-app/stats.json</code></pre><h3>Tree Shaking and Dead Code Elimination</h3><pre><code>// ❌ Bad: Importing entire library\nimport * as _ from 'lodash';\n\n// ✅ Good: Importing only what you need\nimport { debounce, throttle } from 'lodash';\n\n// ✅ Even better: Use specific imports\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';</code></pre><h2>Image Optimization</h2><h3>Using Angular Image Directive (Angular 15+)</h3><pre><code>// Import NgOptimizedImage\nimport { NgOptimizedImage } from '@angular/common';\n\n@Component({\n  selector: 'app-gallery',\n  standalone: true,\n  imports: [NgOptimizedImage],\n  template: `\n    &lt;!-- Optimized image with lazy loading --&gt;\n    &lt;img \n      ngSrc=\"/assets/hero-image.jpg\" \n      alt=\"Hero image\"\n      width=\"1200\" \n      height=\"600\"\n      priority&gt;\n    \n    &lt;!-- Lazy loaded image --&gt;\n    &lt;img \n      ngSrc=\"/assets/gallery/{{ image.src }}\" \n      alt=\"{{ image.alt }}\"\n      width=\"400\" \n      height=\"300\"\n      *ngFor=\"let image of galleryImages\"&gt;\n  `\n})\nexport class GalleryComponent {}</code></pre><h2>Memory Leak Prevention</h2><h3>Subscription Management</h3><pre><code>@Component({\n  selector: 'app-data-component',\n  template: `...`\n})\nexport class DataComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject&lt;void&gt;();\n  \n  constructor(\n    private dataService: DataService,\n    private router: Router\n  ) {}\n  \n  ngOnInit() {\n    // Using takeUntil for automatic unsubscription\n    this.dataService.getData()\n      .pipe(\n        takeUntil(this.destroy$),\n        catchError(error =&gt; {\n          console.error('Error fetching data:', error);\n          return EMPTY;\n        })\n      )\n      .subscribe(data =&gt; {\n        this.processData(data);\n      });\n    \n    // Multiple subscriptions\n    combineLatest([\n      this.dataService.getUsers(),\n      this.dataService.getProducts()\n    ])\n    .pipe(takeUntil(this.destroy$))\n    .subscribe(([users, products]) =&gt; {\n      this.combineData(users, products);\n    });\n  }\n  \n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre><h2>Performance Monitoring</h2><h3>Web Vitals Measurement</h3><pre><code>import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\n@Injectable({ providedIn: 'root' })\nexport class PerformanceService {\n  \n  initWebVitals() {\n    getCLS(this.sendToAnalytics);\n    getFID(this.sendToAnalytics);\n    getFCP(this.sendToAnalytics);\n    getLCP(this.sendToAnalytics);\n    getTTFB(this.sendToAnalytics);\n  }\n  \n  private sendToAnalytics(metric: any) {\n    // Send to your analytics service\n    console.log('Performance metric:', metric);\n    \n    // Example: Send to Google Analytics\n    gtag('event', metric.name, {\n      event_category: 'Web Vitals',\n      event_label: metric.id,\n      value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),\n      non_interaction: true,\n    });\n  }\n}</code></pre><h2>HTTP Performance Optimization</h2><h3>HTTP Interceptors for Caching</h3><pre><code>@Injectable()\nexport class CacheInterceptor implements HttpInterceptor {\n  private cache = new Map&lt;string, HttpResponse&lt;any&gt;&gt;();\n  \n  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    // Only cache GET requests\n    if (req.method !== 'GET') {\n      return next.handle(req);\n    }\n    \n    // Check if request is cacheable\n    if (req.headers.get('Cache-Control') === 'no-cache') {\n      return next.handle(req);\n    }\n    \n    const cachedResponse = this.cache.get(req.url);\n    \n    if (cachedResponse) {\n      // Return cached response\n      return of(cachedResponse.clone());\n    }\n    \n    return next.handle(req).pipe(\n      tap(event =&gt; {\n        if (event instanceof HttpResponse) {\n          // Cache successful responses\n          this.cache.set(req.url, event.clone());\n        }\n      })\n    );\n  }\n}</code></pre><h2>Angular Build Optimizations</h2><h3>Production Build Configuration</h3><pre><code>// angular.json\n\"configurations\": {\n  \"production\": {\n    \"budgets\": [\n      {\n        \"type\": \"initial\",\n        \"maximumWarning\": \"2mb\",\n        \"maximumError\": \"5mb\"\n      },\n      {\n        \"type\": \"anyComponentStyle\",\n        \"maximumWarning\": \"6kb\",\n        \"maximumError\": \"10kb\"\n      }\n    ],\n    \"outputHashing\": \"all\",\n    \"sourceMap\": false,\n    \"namedChunks\": false,\n    \"extractLicenses\": true,\n    \"vendorChunk\": false,\n    \"buildOptimizer\": true,\n    \"optimization\": true,\n    \"aot\": true\n  }\n}</code></pre><h2>Performance Testing and Monitoring</h2><h3>Lighthouse CI Integration</h3><pre><code># Install Lighthouse CI\nnpm install -g @lhci/cli\n\n# lighthouse.config.js\nmodule.exports = {\n  ci: {\n    collect: {\n      url: ['http://localhost:4200'],\n      numberOfRuns: 3\n    },\n    assert: {\n      assertions: {\n        'categories:performance': ['error', { minScore: 0.9 }],\n        'categories:accessibility': ['error', { minScore: 0.9 }],\n        'categories:best-practices': ['error', { minScore: 0.9 }],\n        'categories:seo': ['error', { minScore: 0.9 }]\n      }\n    }\n  }\n};</code></pre><h2>Best Practices Summary</h2><ul><li><strong>Use OnPush change detection strategy</strong> where appropriate</li><li><strong>Implement lazy loading</strong> for feature modules</li><li><strong>Optimize images</strong> with NgOptimizedImage directive</li><li><strong>Prevent memory leaks</strong> with proper subscription management</li><li><strong>Use virtual scrolling</strong> for large datasets</li><li><strong>Implement service workers</strong> for caching and offline support</li><li><strong>Monitor performance</strong> with Web Vitals</li><li><strong>Optimize bundles</strong> with tree shaking and code splitting</li></ul><h2>Conclusion</h2><p>Angular performance optimization is an ongoing process that requires attention to multiple aspects of your application. By implementing these techniques and following best practices, you can create fast, responsive applications that provide excellent user experiences.</p><p>Remember to measure performance before and after optimizations to ensure your changes are having the desired effect. Tools like Lighthouse, Web Vitals, and browser dev tools are invaluable for this process.</p>",
    "coverImage": "assets/img/posts/angular-performance-optimization.webp",
    "date": "2024-03-20",
    "dateModified": "2024-03-25",
    "author": "Mohammad Alshorman",
    "lang": "en",
    "dir": "ltr",
    "tags": ["Angular", "Performance", "Optimization", "Web Development", "TypeScript"],
    "readTime": 18,
    "category": "Frontend Development",
    "slug": "angular-performance-optimization"
  }
]
